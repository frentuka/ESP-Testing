#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "usbmod.h"
#include "usb_descriptors.h"
#include "usb_callbacks.h"

#include "cfgmod.h"

#include "esp_log.h"
#include "esp_err.h"

#include "tinyusb.h"
#include "tinyusb_default_config.h"
#include "tusb.h"

#define TAG "USBModule"

// ============ KEYBOARD HID FUNCTIONS ============

bool usb_keyboard_use_boot_protocol(void)
{
    return (tud_hid_n_get_protocol(ITF_NUM_HID_KBD) == HID_PROTOCOL_BOOT);
}

bool usb_send_keyboard_6kro(uint8_t modifier, const uint8_t keycodes[6])
{
    return tud_hid_n_keyboard_report(ITF_NUM_HID_KBD, REPORT_ID_KEYBOARD, modifier, keycodes);
}

bool usb_send_keyboard_nkro(const uint8_t *bitmap, uint16_t len)
{
    return tud_hid_n_report(ITF_NUM_HID_KBD, REPORT_ID_NKRO, bitmap, len);
}

// Test functions

static void block_until_kb_ready() {
    while (!tud_hid_n_ready(ITF_NUM_HID_KBD)) {
        continue;
    }
}

void usb_send_char(char c)
{
    uint8_t const conv_table[128][2] = { HID_ASCII_TO_KEYCODE };
    uint8_t uichar = (uint8_t) c;
    if (uichar >= 128) return;

    uint8_t kc = conv_table[uichar][1];
    if (kc == 0) return;

    uint8_t mod = conv_table[uichar][0] ? KEYBOARD_MODIFIER_LEFTSHIFT : 0;
    uint8_t keys[6] = { kc };

    if (tud_mounted()) {
        tud_hid_n_keyboard_report(ITF_NUM_HID_KBD, REPORT_ID_KEYBOARD, mod, keys);
        block_until_kb_ready();
        uint8_t no_keys[6] = { 0 };
        tud_hid_n_keyboard_report(ITF_NUM_HID_KBD, REPORT_ID_KEYBOARD, 0, no_keys);
    }
}

void usb_send_keystroke(uint8_t hid_keycode)
{
    if (tud_mounted()) {
        uint8_t keycode[6] = { hid_keycode };
        tud_hid_n_keyboard_report(ITF_NUM_HID_KBD, REPORT_ID_KEYBOARD, 0, keycode);  // Press
        block_until_kb_ready();
        uint8_t no_keys[6] = { 0 };
        tud_hid_n_keyboard_report(ITF_NUM_HID_KBD, REPORT_ID_KEYBOARD, 0, no_keys); // Release
        ESP_LOGI(TAG, "Sent keystroke");
    }
}


/*
    Main USB module
*/

// TinyUSB task
void usb_task(void *arg) {
    while (1) {
        tud_task();
        taskYIELD();
    }
}

void usb_init()
{
    tinyusb_config_t tusb_cfg = TINYUSB_DEFAULT_CONFIG();
    tusb_cfg.descriptor.device = &desc_device;
    tusb_cfg.descriptor.full_speed_config = desc_configuration;
    tusb_cfg.descriptor.string = (const char **)string_desc_arr;
    tusb_cfg.descriptor.string_count = sizeof(string_desc_arr) / sizeof(string_desc_arr[0]);

    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));
    
    xTaskCreatePinnedToCore(usb_task, "usb_task", 4096, NULL, 5, NULL, 1);

    usb_callbacks_init();

    ESP_LOGI(TAG, "USB initialized !");
}

/*
    handle callbacks to usb_callbacks
    (workaround to tinyusb not wanting to link with usb_callbacks)
*/

uint16_t tud_hid_get_report_cb(uint8_t instance,
                              uint8_t report_id,
                              hid_report_type_t report_type,
                              uint8_t *buffer,
                              uint16_t reqlen)
{
    return usbmod_tud_hid_get_report_cb(
        instance,
        report_id,
        report_type,
        buffer,
        reqlen
    );
}

void tud_hid_set_report_cb(uint8_t instance,
                           uint8_t report_id,
                           hid_report_type_t report_type,
                           uint8_t const *buffer,
                           uint16_t bufsize)
{
    usbmod_tud_hid_set_report_cb(
        instance,
        report_id,
        report_type,
        buffer,
        bufsize
    );
}